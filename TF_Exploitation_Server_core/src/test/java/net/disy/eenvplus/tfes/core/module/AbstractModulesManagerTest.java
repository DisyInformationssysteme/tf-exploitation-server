package net.disy.eenvplus.tfes.core.module;

import static java.util.Arrays.asList;
import static net.disy.eenvplus.tfes.core.api.capabilities.ServiceModuleDescriptionMatcher.hasServiceId;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import net.disy.eenvplus.tfes.core.api.capabilities.ParameterDescription;
import net.disy.eenvplus.tfes.core.api.capabilities.ServiceModuleDescription;
import net.disy.eenvplus.tfes.core.api.exceptions.ServiceException;
import net.disy.eenvplus.tfes.core.api.modules.IServiceModule;
import net.disy.eenvplus.tfes.core.api.query.IServiceQuery;
import net.disy.eenvplus.tfes.core.api.query.ISuggestionQuery;
import net.disy.eenvplus.tfes.core.module.AbstractModuleManager;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class AbstractModulesManagerTest {
  private static final String SERVICE_MODUL_ID_1 = "erstes Service Modul"; //$NON-NLS-1$
  private static final String SERVICE_MODUL_ID_2 = "zweites Service Modul"; //$NON-NLS-1$
  private static final String RESULT_1 = "erstes Ergebnis"; //$NON-NLS-1$
  private static final String RESULT_2 = "zweites Ergebnis"; //$NON-NLS-1$

  private interface StubServiceModule extends IServiceModule {
    Callable<String> createCallable();
  }

  @Mock(answer = Answers.RETURNS_DEEP_STUBS)
  private StubServiceModule firstStubModule;
  @Mock(answer = Answers.RETURNS_DEEP_STUBS)
  private StubServiceModule secondStubModule;

  @Mock
  private Future<String> future1;
  @Mock
  private Future<String> future2;

  private AbstractModuleManager<StubServiceModule, IServiceQuery, String> manager = new AbstractModuleManager<StubServiceModule, IServiceQuery, String>() {

    @Override
    protected List<StubServiceModule> getServiceModules() {
      return asList(firstStubModule, secondStubModule);
    }

    @Override
    protected Callable<String> createCallable(IServiceQuery query, StubServiceModule module) {
      return module.createCallable();
    }

  };

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @Before
  public void initServiceModuleMocks() {
    when(firstStubModule.getDescription()). // 
        thenReturn(
            new ServiceModuleDescription(SERVICE_MODUL_ID_1, Collections
                .<ParameterDescription> emptyList()));
    when(secondStubModule.getDescription()). // 
        thenReturn(
            new ServiceModuleDescription(SERVICE_MODUL_ID_2, Collections
                .<ParameterDescription> emptyList()));
  }

  @SuppressWarnings("unchecked")
  @Test
  public void collectsConceptDescriptionsServiceId() {
    List<ServiceModuleDescription> descriptions = manager.getServiceModuleDescription();

    assertThat(
        descriptions,
        containsInAnyOrder(
            hasServiceId(equalTo(SERVICE_MODUL_ID_1)),
            hasServiceId(equalTo(SERVICE_MODUL_ID_2))));

  }

  @Test
  public void delegatesToCallablesFromModules() throws Exception {
    IServiceQuery query = Mockito.mock(IServiceQuery.class);

    manager.submitQuery(query);

    verify(firstStubModule).createCallable();
    verify(secondStubModule).createCallable();
  }

  @Test
  public void delegatesGetSuggestionsOnlyToSelectedModule() throws ServiceException {
    ISuggestionQuery query = mock(ISuggestionQuery.class);
    when(query.getServiceModules()).thenReturn(asList(SERVICE_MODUL_ID_1));

    manager.submitQuery(query);

    verify(firstStubModule).createCallable();
    verify(secondStubModule, never()).createCallable();
  }

  @Test
  public void retrievesCorrectResults() throws Exception {
    when(future1.get()).thenReturn(RESULT_1);
    when(future2.get()).thenReturn(RESULT_2);

    Collection<String> results = manager.retrieveResults(asList(future1, future2));

    assertThat(results, containsInAnyOrder(RESULT_1, RESULT_2));
  }

  @Test
  public void delegatesRecievedServiceExceptions() throws Exception {
    ServiceException expected = new ServiceException(null);
    when(future1.get()).thenReturn(RESULT_1);
    when(future2.get()).thenThrow(new ExecutionException(expected));

    thrown.expect(is(expected));

    manager.retrieveResults(asList(future1, future2));

  }

  @Test
  public void wrapsRecievedInterruptedExceptions() throws Exception {
    InterruptedException expected = new InterruptedException();
    when(future1.get()).thenReturn(RESULT_1);
    when(future2.get()).thenThrow(expected);

    thrown.expect(ServiceException.class);
    thrown.expectCause(is(expected));

    manager.retrieveResults(asList(future1, future2));

  }

}
