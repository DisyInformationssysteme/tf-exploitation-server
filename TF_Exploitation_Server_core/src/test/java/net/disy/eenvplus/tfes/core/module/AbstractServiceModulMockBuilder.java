//Copyright (c) 2014 by Disy Informationssysteme GmbH
package net.disy.eenvplus.tfes.core.module;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;

import net.disy.eenvplus.tfes.core.api.capabilities.ParameterDescription;
import net.disy.eenvplus.tfes.core.api.capabilities.ServiceModuleDescription;
import net.disy.eenvplus.tfes.core.api.modules.IServiceModule;

import org.hamcrest.Matcher;

// NOT_PUBLISHED
public abstract class AbstractServiceModulMockBuilder<M extends IServiceModule, Q, R> {

  private Class<M> moduleClass;
  private List<QueryDescription<Q, R>> answers = new ArrayList<>();
  private String moduleId;

  protected static class QueryDescription<Q, R> {
    private Matcher<Q> matcher;
    private R result;

    public QueryDescription(Matcher<Q> matcher, R result) {
      this.matcher = matcher;
      this.result = result;
    }

    public Matcher<Q> getMatcher() {
      return matcher;
    }

    public R getResult() {
      return result;
    }
  }

  protected AbstractServiceModulMockBuilder(Class<M> moduleClass, String moduleId) {
    this.moduleClass = moduleClass;
    this.moduleId = moduleId;
  }

  public M build() {
    M module = mock(moduleClass);
    for (QueryDescription<Q, R> answer : answers) {
      registerQueryResult(module, answer.getMatcher(), answer.getResult());
    }
    registerEmptyModuleDescription(module, moduleId);
    return module;
  }

  private void registerEmptyModuleDescription(M module, String moduleId) {
    List<ParameterDescription> emptyList = Collections.<ParameterDescription> emptyList();
    ServiceModuleDescription emptyModuleDescription = new ServiceModuleDescription(
        moduleId,
        emptyList);
    when(module.getDescription()).thenReturn(emptyModuleDescription);
  }

  protected abstract void registerQueryResult(M module, Matcher<Q> matcher, R result);

  public AbstractServiceModulMockBuilder<M, Q, R> withAnswer(Matcher<Q> query, R result) {
    answers.add(new QueryDescription<Q, R>(query, result));
    return this;
  }

  protected static <R> Callable<R> createCallable(final R result) {
    return new Callable<R>() {

      @Override
      public R call() throws Exception {
        return result;
      }
    };
  }

}