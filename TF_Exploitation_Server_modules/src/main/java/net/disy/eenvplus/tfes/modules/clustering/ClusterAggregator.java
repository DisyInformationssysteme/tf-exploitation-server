//Copyright (c) 2014 by Disy Informationssysteme GmbH
package net.disy.eenvplus.tfes.modules.clustering;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

// NOT_PUBLISHED

public class ClusterAggregator<E, K, X extends ClusterKeyExtractor<E, K>, C extends Comparator<E>> {

  private X extractor;
  private C comparator;

  public ClusterAggregator(X extractor, C comparator) {
    this.extractor = extractor;
    this.comparator = comparator;
  }

  public Collection<E> findRepresentatives(Collection<E> items) {
    List<Cluster<E, K>> clusters = new LinkedList<>();
    for (E item : items) {
      Set<K> keys = getKeysWithoutNull(item);
      List<Cluster<E, K>> connected = findConnectedClusters(clusters, keys);
      Iterator<Cluster<E, K>> iterator = connected.iterator();
      if (iterator.hasNext()) {
        Cluster<E, K> current = iterator.next();
        mergeIntoAndRemove(current, iterator, clusters);
        addItemCompared(item, current);
      }
      else {
        addNewClusterIfNotFound(clusters, item, keys);
      }
    }
    return createRepresentatives(clusters);
  }

  private Set<K> getKeysWithoutNull(E item) {
    Set<K> keys = new HashSet<>(extractor.extractKeys(item));
    keys.remove(null);
    return keys;
  }

  private void mergeIntoAndRemove(
      Cluster<E, K> current,
      Iterator<Cluster<E, K>> iterator,
      List<Cluster<E, K>> clusters) {
    while (iterator.hasNext()) {
      Cluster<E, K> next = iterator.next();
      mergeInto(current, next);
      clusters.remove(next);
    }
  }

  private void mergeInto(Cluster<E, K> base, Cluster<E, K> toMerge) {
    base.addKeys(toMerge.getKeys());
    addItemCompared(toMerge.getRepresentative(), base);
  }

  private void addItemCompared(E item, Cluster<E, K> cluster) {
    E current = cluster.getRepresentative();
    if (comparator.compare(item, current) > 0) {
      cluster.setRepresentative(item);
    }
  }

  private Collection<E> createRepresentatives(List<Cluster<E, K>> clusters) {
    List<E> result = new ArrayList<>(clusters.size());
    for (Cluster<E, K> cluster : clusters) {
      result.add(cluster.getRepresentative());
    }
    return result;
  }

  private void addNewClusterIfNotFound(List<Cluster<E, K>> clusters, E item, Collection<K> keys) {

    Cluster<E, K> created = new Cluster<>(item, keys);
    clusters.add(created);
  }

  private List<Cluster<E, K>> findConnectedClusters(List<Cluster<E, K>> clusters, Collection<K> keys) {
    List<Cluster<E, K>> found = new LinkedList<>();
    for (Cluster<E, K> cluster : clusters) {
      if (cluster.containsAny(keys)) {
        found.add(cluster);
      }
    }
    return found;
  }
}
